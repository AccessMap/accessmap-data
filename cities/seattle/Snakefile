import json

from osmread import parse_file, Node, Way
from snakemake.remote.HTTP import RemoteProvider as HTTPRemoteProvider

HTTP = HTTPRemoteProvider()


rule all:
    input:
        expand('output/{layer}.geojson', layer=['sidewalks', 'crossings', 'footways',
                                                'kerbs', 'elevators'])

rule fetch_osm:
    input:
        HTTP.remote('https://www.openstreetmap.org/api/0.6/map?bbox=-122.3183%2C47.6435%2C-122.2928%2C47.664',
                    keep_local=True)
    output:
        'interim/raw/extract.osm'
    run:
        shell('mv {input} {output}')


rule extract_sidewalks:
    input:
        'interim/raw/extract.osm'
    output:
        'output/sidewalks.geojson'
    run:
        match_tags = {'highway': 'footway', 'footway': 'sidewalk'}
        keep_tags = ['surface']

        fc = extract_ways(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)


rule extract_crossings:
    input:
        'interim/raw/extract.osm'
    output:
        'output/crossings.geojson'
    run:
        match_tags = {'highway': 'footway', 'footway': 'crossing'}
        keep_tags = ['crossing']

        fc = extract_ways(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)


rule extract_stairs:
    input:
        'interim/raw/extract.osm'
    output:
        'output/stairs.geojson'
    run:
        match_tags = {'highway': 'steps'}

        fc = extract_ways(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)


rule extract_footways:
    input:
        'interim/raw/extract.osm'
    output:
        'output/footways.geojson'
    run:
        match_tags = {'highway': 'footway'}
        nonmatch_tags = {'footway': 'crossing', 'footway': 'sidewalk'}
        keep_tags = ['surface']

        fc = extract_ways(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)

rule extract_kerbs:
    input:
        'interim/raw/extract.osm'
    output:
        'output/kerbs.geojson'
    run:
        match_tags = {'highway': 'footway'}
        nonmatch_tags = {'footway': 'crossing', 'footway': 'sidewalk'}
        keep_tags = ['surface']

        fc = extract_nodes(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)


rule extract_elevators:
    input:
        'interim/raw/extract.osm'
    output:
        'output/elevators.geojson'
    run:
        match_tags = {'highway': 'footway'}
        nonmatch_tags = {'footway': 'crossing', 'footway': 'sidewalk'}
        keep_tags = ['surface']

        fc = extract_nodes(input[0], match_tags, keep_tags)

        with open(output[0], 'w') as f:
            json.dump(fc, f)


def extract_nodes(path, matches, keep, nonmatches=None):
    if nonmatches is None:
        nonmatches = {}

    fc = {'type': 'FeatureCollection', 'features': []}
    for entity in parse_file(path):
        if not isinstance(entity, Node):
            continue

        tags = entity.tags

        # Filters
        invalid = False
        for key, value in matches.items():
            if key not in tags or tags[key] != value:
                invalid = True
                break

        for key, value in nonmatches.items():
            if key in tags and tags[key] == value:
                invalid = True
                break

        if invalid:
            continue

        # Assemble a GeoJSON feature
        feature = {
            'type': 'Feature',
            'geometry': {'type': 'Point', 'coordinates': [entity.lon, entity.lat]},
            'properties': {},
        }

        for key in keep:
            if key in tags:
                feature['properties'][key] = tags[key]

        fc['features'].append(feature)

    return fc


def extract_ways(path, matches, keep, nonmatches=None):
    if nonmatches is None:
        nonmatches = {}

    nodes = {}
    fc = {'type': 'FeatureCollection', 'features': []}
    for entity in parse_file(path):
        if isinstance(entity, Node):
            nodes[entity.id] = entity

        if not isinstance(entity, Way):
            continue

        tags = entity.tags

        # Filters
        invalid = False
        for key, value in matches.items():
            if key not in tags or tags[key] != value:
                invalid = True
                break

        for key, value in nonmatches.items():
            if key in tags and tags[key] == value:
                invalid = True
                break

        if invalid:
            continue

        # Assemble a GeoJSON feature
        feature = {
            'type': 'Feature',
            'geometry': {'type': 'LineString', 'coordinates': []},
            'properties': {},
        }

        coords = [[nodes[n].lon, nodes[n].lat] for n in entity.nodes]

        feature['geometry']['coordinates'] = coords

        for key in keep:
            if key in tags:
                feature['properties'][key] = tags[key]

        fc['features'].append(feature)

    return fc


rule tiles:
    input
